user nginx;
worker_progress auto;
pid /var/run/nginx.pid;

events {
    worker_connections 768;
}

http{
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    
    # Bloco de servidor virtual (um server block) que responde a pedidos HTTP(S)
    server {
        # Indica que esse bloco escuta na porta 443 (padrão HTTPS) e ativa TLS/SSL para essa escuta
        listen      443 ssl;
        listen      [::]:443 ssl;
        # Define quais nomes de host (domínios) esse server block deve atender:
        server_name lpaixao-.42.fr www.lpaixao-.42.fr;
        # Define o diretório raiz onde o nginx procura arquivos estáticos:
        root    /var/www;
        # Indica qual arquivo considerar como índice quando a URL aponta para um diretório:
        index index.php;
        # Caminhos para o certificado e chave privada do TLS. Devem existir dentro do container (ou serem montados via volume):
        ssl_certificate     /etc/nginx/ssl/lpaixao-.42.fr.crt;
        ssl_certificate_key /etc/nginx/ssl/lpaixao-.42.fr.key;
        # Define quais versões do protocolo TLS o servidor irá aceitar:
        ssl_protocols       TLSv1.2 TLSv1.3;
        # Tempo de vida da sessão SSL (cacheamento da sessão para reaproveitar handshake):
        ssl_session_timeout 10m;
        # Tempo (em segundos) que o NGINX mantém conexões keep-alive abertas para o cliente:
        keepalive_timeout 70;
        # Aplica-se a todas as requisições que comecem em /
        location / {
            # Para cada requisição, o Nginx tenta, na ordem:
            # $uri → “Existe um arquivo com exatamente esse nome?”
            # Se não existir → joga a requisição para o index.php, com os parâmetros da URL ($args)
            try_files $uri /index.php?$args;
            # add_header adiciona cabeçalhos HTTP às respostas:
            # date_gmt coloca a data atual do servidor como Last-Modified
            add_header Last-Modified $date_gmt;
            # Instrui navegadores/proxies a não armazenarem o recurso
            add_header Cache-Control 'no-store, no-cache' always;
            # OBS: por padrão add_header só adiciona esses cabeçalhos em respostas com status 200/204/206/301/302/303/304 — se quiser forçar em todas as respostas use add_header ... always

            # Desativa a verificação If-Modified-Since (relacionada ao Last-Modified). Usado quando você não quer que o NGINX responda 304 Not Modified automaticamente.
            if_modified_since off;
            # Desliga a diretiva Expires (evita definir Cache-Control/Expires automáticos)
            expires off;
            # Desliga o envio do cabeçalho ETag
            etag off;
        }
        # Bloco que aplica-se a URIs que terminam em .php (regex)
        location ~ \.php$ {
            include fastcgi_params;
            # Separa o path em SCRIPT_NAME e PATH_INFO quando você tem URLs como /index.php/foo/bar.
            # Há 2 partes captadas pelo regex: grupo1 (.+\.php) e grupo2 (/.+);
            # Depois, o nginx popula $fastcgi_script_name e $fastcgi_path_info
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            # fastcgi_pass aponta para o backend FastCGI (geralmente php-fpm)
            # wordpress:9000 assume que existe um host chamado wordpress resolvível no ambiente (em Docker Compose, wordpress é o nome do serviço) e que o PHP-FPM está escutando na porta 9000. Em Docker Compose isso mapeia para o container do WordPress/PHP-FPM.
            fastcgi_pass wordpress:9000;
            # Define o arquivo index padrão usado pelo FastCGI quando a requisição é para uma diretoria.
            fastcgi_index index.php;
            # Inclui um arquivo de parâmetros FastCGI (variáveis que NGINX passa para o PHP — QUERY_STRING, REQUEST_METHOD, CONTENT_TYPE, etc). O conteúdo exato depende da sua distribuição;
            include fastcgi_params;
            # Configura a variável SCRIPT_FILENAME passada ao PHP-FPM, apontando para o caminho físico do script a ser executado.
            # $document_root é a mesma que root definida no bloco (/var/www).
            # $fastcgi_script_name é a parte do URI que corresponde ao script (por exemplo /index.php).
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            # Passa o PATH_INFO (a parte “extra” após o .php) para o PHP.
            fastcgi_param PATH_INFO $fastcgi_path_info;
        }
    }

    # Um segundo server que escuta em HTTP (porta 80)
    # Bloco de redirecionamento do HTTP para o HTTPS
    server {
        # default_server faz com que esse bloco seja o bloco padrão quando nenhum server_name bate com o Host da requisição.
        listen  80 default_server;
        # habilita IPv6; significa escutar IPv4 e IPv6
        listen  [::]:80 default_server;
        # Define um nome; mas nesse caso como é default_server, ele será escolhido caso não haja correspondência melhor.
        server_name lpaixao-.42.fr;

        # Toda requisição HTTP é redirecionada permanentemente (301) para a mesma URL em https:// (mantendo Host e request_uri).
        # Isso força HTTPS globalmente — prática comum.
        location / {
            return 301 https://$host$request_uri;
        }
    }
}