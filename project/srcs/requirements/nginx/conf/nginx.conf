##############################################
# NGINX configuration file
# Resumo: configuração do servidor web NGINX usada pelo Docker Compose
# Objetivo: servir o site WordPress via HTTPS, encaminhar requests PHP para o
# backend PHP-FPM (serviço 'wordpress') e redirecionar HTTP para HTTPS.
# Variáveis/recursos esperados:
#  - certificados TLS em /etc/nginx/ssl/lpaixao-.42.fr.crt e .key (montados via volume)
#  - arquivos web em /var/www/html (montados via volume)
# Observações:
#  - Este arquivo assume que o serviço 'wordpress' é resolvível pelo nome no
#    ambiente Docker Compose e que o PHP-FPM está escutando na porta 9000.
##############################################

upstream wordpress_server {
    # Define o backend FastCGI (PHP-FPM) para onde as requisições PHP serão encaminhadas
    server wordpress:9000;
}

server {
    # Indica que esse bloco escuta na porta 443 (padrão HTTPS) e ativa TLS/SSL para essa escuta
    # IPV4
    listen      443 ssl;
    # IPV6
    listen      [::]:443 ssl;
    # Define quais nomes de host (domínios) esse server block deve atender:
    server_name lpaixao-.42.fr www.lpaixao-.42.fr;
    # Define o diretório raiz onde o nginx procura arquivos estáticos:
    root    /var/www/html;
    # Indica qual arquivo considerar como índice quando a URL aponta para um diretório:
    index index.php;
    # Caminhos para o certificado e chave privada do TLS. Devem existir dentro do container (ou serem montados via volume):
    ssl_certificate     /etc/nginx/ssl/lpaixao-.42.fr.crt;
    ssl_certificate_key /etc/nginx/ssl/lpaixao-.42.fr.key;
    # Define quais versões do protocolo TLS o servidor irá aceitar:
    ssl_protocols       TLSv1.2 TLSv1.3;
    # Tempo de vida da sessão SSL (cacheamento da sessão para reaproveitar handshake):
    ssl_session_timeout 10m;
    # Tempo (em segundos) que o NGINX mantém conexões keep-alive abertas para o cliente:
    keepalive_timeout 70;
    # Aplica-se a todas as requisições que comecem em /
    location / {
        # Para cada requisição, o Nginx tenta, na ordem:
        # $uri → “Existe um arquivo com exatamente esse nome?”
        # Se não existir → joga a requisição para o index.php, com os parâmetros da URL ($args)
        try_files $uri /index.php?$args;
        # add_header adiciona cabeçalhos HTTP às respostas:
        # date_gmt coloca a data atual do servidor como Last-Modified
        add_header Last-Modified $date_gmt;
        # Instrui navegadores/proxies a não armazenarem o recurso
        add_header Cache-Control 'no-store, no-cache' always;
        # OBS: por padrão add_header só adiciona esses cabeçalhos em respostas com status 200/204/206/301/302/303/304 — se quiser forçar em todas as respostas use add_header ... always

        # Desativa a verificação If-Modified-Since (relacionada ao Last-Modified). Usado quando você não quer que o NGINX responda 304 Not Modified automaticamente.
        if_modified_since off;
        # Desliga a diretiva Expires (evita definir Cache-Control/Expires automáticos)
        expires off;
        # Desliga o envio do cabeçalho ETag
        etag off;
    }
    # Bloco que aplica-se a URIs que terminam em .php (regex)
    location ~ \.php$ {
        include fastcgi_params;
        # Separa o path em SCRIPT_NAME e PATH_INFO quando você tem URLs como /index.php/foo/bar.
        # Há 2 partes captadas pelo regex: grupo1 (.+\.php) e grupo2 (/.+);
        # Depois, o nginx popula $fastcgi_script_name e $fastcgi_path_info
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        # fastcgi_pass aponta para o backend FastCGI (geralmente php-fpm)
        # wordpress:9000 assume que existe um host chamado wordpress resolvível no ambiente (em Docker Compose, wordpress é o nome do serviço) e que o PHP-FPM está escutando na porta 9000. Em Docker Compose isso mapeia para o container do WordPress/PHP-FPM.
        fastcgi_pass wordpress:9000;
        # Define o arquivo index padrão usado pelo FastCGI quando a requisição é para uma diretoria.
        fastcgi_index index.php;
        # Inclui um arquivo de parâmetros FastCGI (variáveis que NGINX passa para o PHP — QUERY_STRING, REQUEST_METHOD, CONTENT_TYPE, etc). O conteúdo exato depende da sua distribuição;
        include fastcgi_params;
        # Configura a variável SCRIPT_FILENAME passada ao PHP-FPM, apontando para o caminho físico do script a ser executado.
        # $document_root é a mesma que root definida no bloco (/var/www/html).
        # $fastcgi_script_name é a parte do URI que corresponde ao script (por exemplo /index.php).
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        # Passa o PATH_INFO (a parte “extra” após o .php) para o PHP.
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}